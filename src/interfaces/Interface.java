package interfaces;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/***
 * Copyright (C) RandomeStudios. All rights reserved.
 *
 * @author Sachin Gavali
 * <p>
 * =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 * Class        : Interface
 * Package      : interfaces
 * <p>
 * <p>
 * This class represents the interface object, that is generated by parsing the inteface defination file
 * <p>
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 */

public class Interface {
    private String mHeaderName;

    private List<String> mFunctionToIgnore = new ArrayList<>();
    private List<String> mImportFilesHeader = new ArrayList<>();
    private List<String> mImportFilesSource = new ArrayList<>();
    private List<String> mConstructorsToIgnore = new ArrayList<>();
    private List<String> mMemOwners = new ArrayList<>();
    private HashMap<String, String> functionToRename = new HashMap<>();

    private String mHeaderDirName = "";
    private String mParentHeader = "";
    private String mParentHeaderDir = "";
    private boolean mIsParentTemplate = false;

    public void addFunctionToIgnore(String line) {
        mFunctionToIgnore.add(line);
    }


    public void addImportFileHeader(String importFile) {
        mImportFilesHeader.add(importFile);
    }

    public List<String> getImportFilesHeader() {
        return mImportFilesHeader;
    }

    public void addImportFileSource(String importFile) {
        mImportFilesSource.add(importFile);
    }

    public List<String> getImportFilesSource() {
        return mImportFilesSource;
    }

    public String getTranslationUnitHeaderName() {
        return mHeaderName.replace(".h", "") + "Wrapper.h";
    }

    public String getTranslationUnitSourceName() {
        return mHeaderName.replace(".h", "") + "Wrapper.cpp";
    }

    public boolean isFunctionIgnored(String currentLine) {
        for (String function : mFunctionToIgnore) {
            if (currentLine.equals(function)) {
                return true;
            }
        }
        return false;
    }

    public boolean isConstructorIgnored(String currentLine) {
        for (String function : mConstructorsToIgnore) {
            if (currentLine.equals(function)) {
                return true;
            }
        }
        return false;
    }

    public void addFunctionRename(String fromName, String toName) {
        functionToRename.put(fromName, toName);
    }

    public String getFunctionRenameMapping(String funcName) {
        String value = functionToRename.getOrDefault(funcName, funcName);
        return value;
    }

    public void setHeaderFileName(String headerFileName, String dirName) {
        mHeaderName = headerFileName;
        mHeaderDirName = dirName;
    }

    public String getHeaderName() {
        return mHeaderName;
    }

    public String getHeaderDirName() {
        return mHeaderDirName;
    }

    public String getFullHeaderName() {
        if (mHeaderDirName.equals("")) {
            return mHeaderName;
        } else {
            return mHeaderDirName + "\\" + mHeaderName;
        }
    }

    public void addConstructorsToIgnore(String constructorLine) {
        mConstructorsToIgnore.add(constructorLine);
    }


    public void setParentHeaderFileName(String headerName, String directoryName) {
        mParentHeader = headerName;
        mParentHeaderDir = directoryName;
    }

    public String getParentHeaderFileName() {
        return mParentHeader;
    }

    public String getParentHeaderDirName() {
        return mParentHeaderDir;
    }

    public void addToMemoryOwners(String functionLine) {
        mMemOwners.add(functionLine);
    }

    public boolean ownsMemory(String functionLine) {
        return mMemOwners.contains(functionLine);
    }

    public String getMemOwnStr(String line) {
        boolean memOwn = ownsMemory(line);
        if (memOwn) {
            return "false";
        } else {
            return "true";
        }
    }

    public void setParentIsTemplate(boolean isParentTemplate) {
        mIsParentTemplate = isParentTemplate;
    }

    public boolean getIsParentTemplated() {
        return mIsParentTemplate;
    }

}
